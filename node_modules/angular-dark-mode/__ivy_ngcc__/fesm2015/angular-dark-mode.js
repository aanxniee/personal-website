import * as i0 from '@angular/core';
import { InjectionToken, Injectable, RendererFactory2, Optional, Inject } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { distinctUntilChanged } from 'rxjs/operators';

/**
 * InjectionToken to override default options
 *
 * @example
 *
 * providers: [
 *   {
 *     provide: DARK_MODE_OPTIONS,
 *     useValue: {
 *       darkModeClass: 'my-dark-mode',
 *       lightModeClass: 'my-light-mode',
 *     },
 *   },
 * ]
 */
import * as ɵngcc0 from '@angular/core';
const DARK_MODE_OPTIONS = new InjectionToken('DARK_MODE_OPTIONS');

/**
 * Default options used in DarkModeService
 */
const defaultOptions = {
    darkModeClass: 'dark-mode',
    lightModeClass: 'light-mode',
    preloadingClass: 'dark-mode-preloading',
    storageKey: 'dark-mode',
    element: document.body,
};

/* eslint-disable @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any */
function isNil(value) {
    return value === null || value === undefined;
}

const prefersDarkSchemeQuery = '(prefers-color-scheme: dark)';

class MediaQueryService {
    matchMedia(query) {
        return window.matchMedia(query);
    }
    prefersDarkMode() {
        return this.matchMedia(prefersDarkSchemeQuery).matches;
    }
}
MediaQueryService.ɵfac = function MediaQueryService_Factory(t) { return new (t || MediaQueryService)(); };
MediaQueryService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MediaQueryService_Factory() { return new MediaQueryService(); }, token: MediaQueryService, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MediaQueryService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], null, null); })();

class DarkModeService {
    constructor(rendererFactory, mediaQueryService, 
    // prettier-ignore
    providedOptions) {
        this.rendererFactory = rendererFactory;
        this.mediaQueryService = mediaQueryService;
        this.providedOptions = providedOptions;
        this.options = Object.assign(Object.assign({}, defaultOptions), (this.providedOptions || {}));
        this.renderer = this.rendererFactory.createRenderer(null, null);
        this.darkModeSubject$ = new BehaviorSubject(this.getInitialDarkModeValue());
        this.darkModeSubject$.getValue() ? this.enable() : this.disable();
        this.removePreloadingClass();
    }
    /**
     * An Observable representing current dark mode.
     * Only fires the initial and distinct values.
     */
    get darkMode$() {
        return this.darkModeSubject$.asObservable().pipe(distinctUntilChanged());
    }
    toggle() {
        this.darkModeSubject$.getValue() ? this.disable() : this.enable();
    }
    enable() {
        const { element, darkModeClass, lightModeClass } = this.options;
        this.renderer.removeClass(element, lightModeClass);
        this.renderer.addClass(element, darkModeClass);
        this.saveDarkModeToStorage(true);
        this.darkModeSubject$.next(true);
    }
    disable() {
        const { element, darkModeClass, lightModeClass } = this.options;
        this.renderer.removeClass(element, darkModeClass);
        this.renderer.addClass(element, lightModeClass);
        this.saveDarkModeToStorage(false);
        this.darkModeSubject$.next(false);
    }
    getInitialDarkModeValue() {
        const darkModeFromStorage = this.getDarkModeFromStorage();
        if (isNil(darkModeFromStorage)) {
            return this.mediaQueryService.prefersDarkMode();
        }
        return darkModeFromStorage;
    }
    saveDarkModeToStorage(darkMode) {
        localStorage.setItem(this.options.storageKey, JSON.stringify({ darkMode }));
    }
    getDarkModeFromStorage() {
        var _a;
        const storageItem = localStorage.getItem(this.options.storageKey);
        if (storageItem) {
            try {
                return (_a = JSON.parse(storageItem)) === null || _a === void 0 ? void 0 : _a.darkMode;
            }
            catch (error) {
                console.error('Invalid darkMode localStorage item:', storageItem, 'falling back to color scheme media query');
            }
        }
        return null;
    }
    removePreloadingClass() {
        // defer to next tick
        setTimeout(() => {
            this.renderer.removeClass(this.options.element, this.options.preloadingClass);
        });
    }
}
DarkModeService.ɵfac = function DarkModeService_Factory(t) { return new (t || DarkModeService)(ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2), ɵngcc0.ɵɵinject(MediaQueryService), ɵngcc0.ɵɵinject(DARK_MODE_OPTIONS, 8)); };
DarkModeService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DarkModeService_Factory() { return new DarkModeService(i0.ɵɵinject(i0.RendererFactory2), i0.ɵɵinject(MediaQueryService), i0.ɵɵinject(DARK_MODE_OPTIONS, 8)); }, token: DarkModeService, providedIn: "root" });
DarkModeService.ctorParameters = () => [
    { type: RendererFactory2 },
    { type: MediaQueryService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DARK_MODE_OPTIONS,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DarkModeService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc0.RendererFactory2 }, { type: MediaQueryService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DARK_MODE_OPTIONS]
            }] }]; }, null); })();

/*
 * Public API Surface of angular-dark-mode
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DARK_MODE_OPTIONS, DarkModeService, MediaQueryService as ɵa };

//# sourceMappingURL=angular-dark-mode.js.map